# Админ-панель чатов NanoBanana

Документ описывает новую панель администратора, которая позволяет просматривать переписку пользователей с Telegram-ботом и служит основой для будущих модулей (рассылки, аналитика).

## Возможности

- Список всех диалогов (`/dashboard/`):
  - имя и username пользователя;
  - время и превью последнего сообщения;
  - индикатор количества непрочитанных входящих.
- Просмотр истории конкретного чата (`/dashboard/chats/<id>/`):
  - полная лента сообщений (текст, медиа, кто отправил, точное время);
  - предпросмотр изображений и скачивание любого вложения через прокси.
- inline-клавиатуры отображаются точно так же, как в Telegram, а каждое нажатие фиксируется отдельным событием «Нажал кнопку …».
- Все действия доступны только сотрудникам (`is_staff=True`) через стандартную авторизацию Django.

## Как запустить локально

```bash
# 1. Установить зависимости
pip install -r requirements.txt

# 2. Выполнить миграции
DATABASE_URL=sqlite:///db.sqlite3 python manage.py migrate

# 3. Создать суперпользователя
DATABASE_URL=sqlite:///db.sqlite3 python manage.py createsuperuser

# 4. Запустить сервер
DATABASE_URL=sqlite:///db.sqlite3 python manage.py runserver
```

После логина на `/admin/login/` панель доступна по адресу `http://127.0.0.1:8000/dashboard/`.

### Настройка доменов в облаке

Если панель открываете по HTTPS-домену (Railway, собственный хостинг), добавьте его в переменную окружения `CSRF_TRUSTED_ORIGINS`, иначе Django отклонит вход (403 CSRF). Пример для staging и production:

```
CSRF_TRUSTED_ORIGINS=https://web-staging-70d1.up.railway.app,https://app.nanobanana.ai
```

Переменную можно задать в Railway → Variables на каждом сервисе (`web`, `worker`, `beat`).

## Ручная проверка перед релизом

1. Убедитесь, что миграции применены (`python manage.py migrate`) и есть staff‑пользователь.
2. Отправьте несколько сообщений (текст и медиа) в Telegram‑бот, чтобы сформировать диалог.
3. Авторизуйтесь на `/dashboard/` → проверьте список чатов:
   - отображаются имя/username/превью последнего сообщения;
   - поле «Новые» растёт после входящих и сбрасывается после открытия диалога.
4. Откройте конкретный чат:
   - вся переписка отражается в хронологическом порядке;
   - изображения показываются в предпросмотре, другие медиа скачиваются по ссылке;
   - время и направление сообщения соответствуют фактическим.
   - если бот присылает inline-клавиатуру, убедитесь, что она отображается и нажатия пользователя появляются как отдельные входящие.
5. Повторно отправьте сообщение от бота и убедитесь, что исходящие тоже логируются.
6. Для файлов >20 MB проверьте, что прокси выдаёт корректный `Content-Type` и скачивание проходит без ошибок.

## Как собираются чаты

1. **Новые модели** (`botapp/models.py`):
   - `ChatThread` — диалог с пользователем, содержит краткую сводку и индексы.
   - `ChatMessage` — конкретное сообщение (направление, тип, текст, метаданные медиа).
2. **Логирование входящих**:
   - middleware `ChatLoggingMiddleware` (подключена к главному роутеру aiogram) фиксирует каждое сообщение от пользователя.
3. **Логирование исходящих**:
   - класс `LoggingBot` оборачивает `aiogram.Bot` и сохраняет каждое отправленное ботом сообщение;
   - сериализует inline-клавиатуру в `payload`, чтобы админ видел состав кнопок.
4. **Логирование нажатий inline-кнопок**:
   - `ChatLoggingMiddleware` обрабатывает не только `Message`, но и `CallbackQuery`;
   - каждое нажатие записывается отдельным входящим сообщением («Нажал кнопку …») с кнопкой, по которой щёлкнул пользователь.
5. **Очередность событий**:
   - для исходящих сообщений используем `timezone.now()` как `message_date`, чтобы они всегда шли в истории после событий пользователя, даже если Telegram прислал более ранний timestamp.
6. Медиа сохраняются с `file_id`; просмотр происходит через `MessageMediaProxyView`, которая запрашивает файл у Telegram по токену бота и отдаёт его админу.

## Будущее расширение

- Разделы «Рассылки» и «Аналитика» уже зарезервированы в навигации панели.
- API для чатов строится поверх БД (Django ORM), поэтому легко добавляются JSON-endpoint'ы для SPA/мобильных клиентов, если понадобится.
- Для аналитики предусмотрены базовые поля (`message_type`, `direction`, `last_message_at`), а также JSON-поле `payload` для дополнительных параметров.

## Требования безопасности

- Все запросы проходят через стандартную Django-аутентификацию и проверку `is_staff`.
- Токен Telegram не раскрывается в интерфейсе: скачивание медиа идёт через прокси-вьюху.
- Не публикуйте ссылки из `/dashboard/messages/<id>/media/` во внешних каналах, потому что доступ к ним зависит от сессии администратора.
