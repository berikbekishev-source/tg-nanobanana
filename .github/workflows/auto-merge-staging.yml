name: Auto-merge to staging

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [staging]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    # Concurrency group –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –º–µ—Ä–¥–∂–µ–π
    concurrency:
      group: staging-deploy
      cancel-in-progress: false
    
    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0

      - name: Wait for CI to complete
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request.number;
            const maxWait = 10 * 60 * 1000; // 10 –º–∏–Ω—É—Ç
            const start = Date.now();
            
            while (Date.now() - start < maxWait) {
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.payload.pull_request.head.sha
              });
              
              const ciChecks = checks.check_runs.filter(c => 
                c.name.includes('build-test') || c.name === 'CI / build-test'
              );
              
              if (ciChecks.length === 0) {
                core.info('No CI checks found yet, waiting...');
                await new Promise(r => setTimeout(r, 10000));
                continue;
              }
              
              const allDone = ciChecks.every(c => c.status === 'completed');
              const allSuccess = ciChecks.every(c => c.conclusion === 'success');
              
              if (allDone && allSuccess) {
                core.info('‚úÖ All CI checks passed!');
                return;
              }
              
              if (allDone && !allSuccess) {
                core.setFailed('‚ùå CI checks failed');
                return;
              }
              
              core.info('Waiting for CI checks to complete...');
              await new Promise(r => setTimeout(r, 10000));
            }
            
            core.setFailed('Timeout waiting for CI checks');

      - name: Merge PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMIN_GH_TOKEN || github.token }}
          script: |
            const pr = context.payload.pull_request.number;
            
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr,
                merge_method: 'squash',
                commit_title: `${context.payload.pull_request.title} (#${pr})`,
                commit_message: 'Auto-merged by staging pipeline'
              });
              
              core.info(`‚úÖ PR #${pr} merged successfully`);
            } catch (error) {
              core.setFailed(`Failed to merge PR: ${error.message}`);
            }

      - name: Wait for Railway deployment
        shell: bash
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          set -euo pipefail
          
          RAILWAY_PROJECT_ID="866bc61a-0ef1-41d1-af53-26784f6e5f06"
          STAGING_ENV_ID="9e15b55d-8220-4067-a47e-191a57c2bcca"
          RAILWAY_GRAPHQL="https://backboard.railway.app/graphql/v2"
          
          echo "‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –¥–µ–ø–ª–æ—è Railway..."
          deadline=$(( $(date +%s) + 300 )) # 5 –º–∏–Ω—É—Ç
          
          while true; do
            json=$(curl -fsSk -H "Authorization: Bearer ${RAILWAY_API_TOKEN}" \
              -H 'Content-Type: application/json' \
              -d '{"query":"query($id:String!){project(id:$id){services{edges{node{name serviceInstances{edges{node{environmentId latestDeployment{status}}}}}}}}","variables":{"id":"'"$RAILWAY_PROJECT_ID"'"}}' \
              "$RAILWAY_GRAPHQL")
            
            statuses=$(echo "$json" | jq -r --arg EID "$STAGING_ENV_ID" \
              '.data.project.services.edges[].node | select(.name=="web" or .name=="worker" or .name=="beat") | .serviceInstances.edges[] | select(.node.environmentId==$EID) | .node.latestDeployment.status' || true)
            
            echo "–°—Ç–∞—Ç—É—Å—ã: $statuses"
            
            all_success=true
            for s in $statuses; do
              if [[ "$s" != "SUCCESS" ]]; then
                all_success=false
              fi
            done
            
            if $all_success && [[ -n "$statuses" ]]; then
              echo "‚úÖ –í—Å–µ —Å–µ—Ä–≤–∏—Å—ã –∑–∞–¥–µ–ø–ª–æ–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ"
              break
            fi
            
            if (( $(date +%s) > deadline )); then
              echo "‚ö†Ô∏è Timeout –æ–∂–∏–¥–∞–Ω–∏—è –¥–µ–ø–ª–æ—è"
              exit 1
            fi
            
            sleep 15
          done

      - name: Update deployment marker
        shell: bash
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          ACTOR: ${{ github.actor }}
          PUSH_TOKEN: ${{ secrets.ADMIN_GH_TOKEN || github.token }}
        run: |
          set -euo pipefail
          
          # –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ staging
          git fetch origin staging
          git checkout staging
          git pull origin staging
          
          # –û–±–Ω–æ–≤–ª—è–µ–º –º–∞—Ä–∫–µ—Ä –¥–µ–ø–ª–æ—è
          cat > STAGING_DEPLOYED.json <<EOF
          {
            "pr": $PR_NUMBER,
            "title": "$PR_TITLE",
            "actor": "$ACTOR",
            "deployed_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "commit": "$(git rev-parse HEAD)",
            "commit_short": "$(git rev-parse --short HEAD)"
          }
          EOF
          
          git add STAGING_DEPLOYED.json
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git commit -m "ci: update staging deployment marker (PR #$PR_NUMBER)"
          
          # Push —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏
          for i in {1..3}; do
            git remote set-url origin https://x-access-token:${PUSH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git
            if git push origin staging; then
              echo "‚úÖ –ú–∞—Ä–∫–µ—Ä –¥–µ–ø–ª–æ—è –æ–±–Ω–æ–≤–ª—ë–Ω"
              exit 0
            fi
            echo "‚ö†Ô∏è Push failed, retrying..."
            git pull --rebase origin staging
            sleep 5
          done
          
          echo "‚ö†Ô∏è Failed to push deployment marker"
          exit 1

      - name: Comment success
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request.number;
            const body = `‚úÖ **–î–µ–ø–ª–æ–π –≤ staging –∑–∞–≤–µ—Ä—à—ë–Ω**
            
            üöÄ Railway: –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã (web, worker, beat) ‚Üí SUCCESS
            üìù –ú–∞—Ä–∫–µ—Ä –¥–µ–ø–ª–æ—è –æ–±–Ω–æ–≤–ª—ë–Ω: PR #${pr}
            üîç –ü—Ä–æ–≤–µ—Ä–∏—Ç—å: \`railway variables | grep STAGING_DEPLOYED\`
            
            **–°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏:**
            1. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ health: https://web-staging-70d1.up.railway.app/api/health
            2. –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä—É–π—Ç–µ –≤ @test_integer_ai_bot
            3. –ü–æ—Å–ª–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–∑–¥–∞–π—Ç–µ PR staging ‚Üí main`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr,
              body
            });
# CI trigger
