name: Auto-merge to staging

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [staging]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    # Concurrency group –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –º–µ—Ä–¥–∂–µ–π
    concurrency:
      group: staging-deploy
      cancel-in-progress: false
    
    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0

      - name: Wait for CI to complete
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request.number;
            const maxWait = 10 * 60 * 1000; // 10 –º–∏–Ω—É—Ç
            const start = Date.now();
            
            while (Date.now() - start < maxWait) {
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.payload.pull_request.head.sha
              });
              
              const ciChecks = checks.check_runs.filter(c => 
                c.name.includes('build-test') || c.name === 'CI / build-test'
              );
              
              if (ciChecks.length === 0) {
                core.info('No CI checks found yet, waiting...');
                await new Promise(r => setTimeout(r, 10000));
                continue;
              }
              
              const allDone = ciChecks.every(c => c.status === 'completed');
              const allSuccess = ciChecks.every(c => c.conclusion === 'success');
              
              if (allDone && allSuccess) {
                core.info('‚úÖ All CI checks passed!');
                return;
              }
              
              if (allDone && !allSuccess) {
                core.setFailed('‚ùå CI checks failed');
                return;
              }
              
              core.info('Waiting for CI checks to complete...');
              await new Promise(r => setTimeout(r, 10000));
            }
            
            core.setFailed('Timeout waiting for CI checks');

      - name: Merge PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMIN_GH_TOKEN || github.token }}
          script: |
            const pr = context.payload.pull_request.number;
            
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr,
                merge_method: 'squash',
                commit_title: `${context.payload.pull_request.title} (#${pr})`,
                commit_message: 'Auto-merged by staging pipeline'
              });
              
              core.info(`‚úÖ PR #${pr} merged successfully`);
            } catch (error) {
              core.setFailed(`Failed to merge PR: ${error.message}`);
            }

      - name: Wait for Railway deployment
        shell: bash
        env:
          RAILWAY_API_TOKEN: ${{ secrets.RAILWAY_API_TOKEN }}
        run: |
          set -euo pipefail
          
          RAILWAY_PROJECT_ID="866bc61a-0ef1-41d1-af53-26784f6e5f06"
          STAGING_ENV_ID="9e15b55d-8220-4067-a47e-191a57c2bcca"
          RAILWAY_GRAPHQL="https://backboard.railway.app/graphql/v2"
          
          echo "‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –¥–µ–ø–ª–æ—è Railway..."
          deadline=$(( $(date +%s) + 300 )) # 5 –º–∏–Ω—É—Ç
          
          while true; do
            json=$(curl -fsSk -H "Authorization: Bearer ${RAILWAY_API_TOKEN}" \
              -H 'Content-Type: application/json' \
              -d '{"query":"query{project(id: \"'"$RAILWAY_PROJECT_ID"'\"){services{edges{node{name serviceInstances{edges{node{environmentId latestDeployment{status}}}}}}}}}"}' \
              "$RAILWAY_GRAPHQL")
            
            statuses=$(echo "$json" | jq -r --arg EID "$STAGING_ENV_ID" \
              '.data.project.services.edges[].node | select(.name=="web" or .name=="worker" or .name=="beat") | .serviceInstances.edges[] | select(.node.environmentId==$EID) | .node.latestDeployment.status' || true)
            
            echo "–°—Ç–∞—Ç—É—Å—ã: $statuses"
            
            all_success=true
            for s in $statuses; do
              if [[ "$s" != "SUCCESS" ]]; then
                all_success=false
              fi
            done
            
            if $all_success && [[ -n "$statuses" ]]; then
              echo "‚úÖ –í—Å–µ —Å–µ—Ä–≤–∏—Å—ã –∑–∞–¥–µ–ø–ª–æ–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ"
              break
            fi
            
            if (( $(date +%s) > deadline )); then
              echo "‚ö†Ô∏è Timeout –æ–∂–∏–¥–∞–Ω–∏—è –¥–µ–ø–ª–æ—è"
              exit 1
            fi
            
            sleep 15
          done

      - name: Update deployment marker via GitHub API
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMIN_GH_TOKEN || github.token }}
          script: |
            const pr = context.payload.pull_request.number;
            const title = context.payload.pull_request.title;
            const actor = context.actor;
            const sha = context.payload.pull_request.merge_commit_sha;
            const shortSha = sha ? sha.substring(0, 7) : 'unknown';
            
            // –°–æ–∑–¥–∞—ë–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞
            const content = JSON.stringify({
              pr: pr,
              title: title,
              actor: actor,
              deployed_at: new Date().toISOString(),
              commit: sha || 'unknown',
              commit_short: shortSha
            }, null, 2);
            
            try {
              // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π SHA —Ñ–∞–π–ª–∞
              const currentFile = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'STAGING_DEPLOYED.json',
                ref: 'staging'
              });
              
              // –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–∞–π–ª —á–µ—Ä–µ–∑ API (bypass branch protection)
              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'STAGING_DEPLOYED.json',
                message: `ci: update staging deployment marker (PR #${pr})`,
                content: Buffer.from(content).toString('base64'),
                branch: 'staging',
                sha: currentFile.data.sha
              });
              
              core.info('‚úÖ –ú–∞—Ä–∫–µ—Ä –¥–µ–ø–ª–æ—è –æ–±–Ω–æ–≤–ª—ë–Ω —á–µ—Ä–µ–∑ GitHub API');
            } catch (error) {
              core.warning(`‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –º–∞—Ä–∫–µ—Ä –¥–µ–ø–ª–æ—è: ${error.message}`);
              // –ù–µ —Ñ–µ–π–ª–∏–º –≤–µ—Å—å workflow, –µ—Å–ª–∏ –º–∞—Ä–∫–µ—Ä –Ω–µ –æ–±–Ω–æ–≤–∏–ª—Å—è
            }

      - name: Comment success
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request.number;
            const body = `‚úÖ **–î–µ–ø–ª–æ–π –≤ staging –∑–∞–≤–µ—Ä—à—ë–Ω**
            
            üöÄ Railway: –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã (web, worker, beat) ‚Üí SUCCESS
            üìù –ú–∞—Ä–∫–µ—Ä –¥–µ–ø–ª–æ—è –æ–±–Ω–æ–≤–ª—ë–Ω: PR #${pr}
            üîç –ü—Ä–æ–≤–µ—Ä–∏—Ç—å: \`railway variables | grep STAGING_DEPLOYED\`
            
            **–°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏:**
            1. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ health: https://web-staging-70d1.up.railway.app/api/health
            2. –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä—É–π—Ç–µ –≤ @test_integer_ai_bot
            3. –ü–æ—Å–ª–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–∑–¥–∞–π—Ç–µ PR staging ‚Üí main`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr,
              body
            });
